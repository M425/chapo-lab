# ============================================
# Initial Setup & Cloud-Init Wait
# ============================================
- name: Wait for cloud-init to complete
  raw: test -f /var/lib/cloud/instance/boot-finished
  retries: 30
  delay: 10
  register: cloud_init_check
  until: cloud_init_check.rc == 0
  changed_when: false

- name: Install Python for Ansible
  raw: apt update && apt install -y python3 python3-apt
  changed_when: false

# Now we can gather facts
- name: Gather facts after Python installation
  setup:

# ============================================
# System Configuration
# ============================================
- name: Set timezone
  timezone:
    name: "{{ ubu_timezone }}"

- name: Set hostname
  hostname:
    name: "{{ inventory_hostname }}"

- name: Update /etc/hosts with hostname
  lineinfile:
    path: /etc/hosts
    regexp: '^127\.0\.1\.1'
    line: "127.0.1.1 {{ inventory_hostname }}"

# failing
#- name: Configure locale
#  locale_gen:
#    name: en_US.UTF-8
#    state: present

# ============================================
# Package Management
# ============================================
- name: Update apt cache
  apt:
    update_cache: yes
    cache_valid_time: 3600

- name: Upgrade all packages
  apt:
    upgrade: dist
    autoremove: yes
    autoclean: yes

- name: Install essential packages
  apt:
    name:
      - apt-transport-https
      - ca-certificates
      - curl
      - gnupg
      - lsb-release
      - software-properties-common
      - git
      - vim
      - htop
      - tmux
      - wget
      - unzip
      - net-tools
      - dnsutils
      - jq
      - ncdu
      - tree
      - rsync
      - nfs-common

    state: present

# ============================================
# Security Configuration
# ============================================
- name: Configure automatic security updates
  apt:
    name:
      - unattended-upgrades
      - apt-listchanges
    state: present
  when: ubu_enable_auto_updates

- name: Configure unattended-upgrades
  copy:
    dest: /etc/apt/apt.conf.d/50unattended-upgrades
    content: |
      Unattended-Upgrade::Allowed-Origins {
          "${distro_id}:${distro_codename}-security";
          "${distro_id}ESMApps:${distro_codename}-apps-security";
          "${distro_id}ESM:${distro_codename}-infra-security";
      };
      Unattended-Upgrade::AutoFixInterruptedDpkg "true";
      Unattended-Upgrade::MinimalSteps "true";
      Unattended-Upgrade::Remove-Unused-Kernel-Packages "true";
      Unattended-Upgrade::Remove-Unused-Dependencies "true";
      Unattended-Upgrade::Automatic-Reboot "false";
  when: ubu_enable_auto_updates

- name: Enable automatic updates
  copy:
    dest: /etc/apt/apt.conf.d/20auto-upgrades
    content: |
      APT::Periodic::Update-Package-Lists "1";
      APT::Periodic::Unattended-Upgrade "1";
      APT::Periodic::AutocleanInterval "7";
  when: ubu_enable_auto_updates

- name: Install and configure UFW
  apt:
    name: ufw
    state: present

#    - name: Set UFW default policies
#      ufw:
#        direction: "{{ item.direction }}"
#        policy: "{{ item.policy }}"
#      loop:
#        - { direction: 'incoming', policy: 'deny' }
#        - { direction: 'outgoing', policy: 'allow' }
#        - { direction: 'routed', policy: 'deny' }
#
#    - name: Allow specified ports through UFW
#      ufw:
#        rule: allow
#        port: "{{ item.split('/')[0] }}"
#        proto: "{{ item.split('/')[1] }}"
#      loop: "{{ ubu_ufw_allowed_ports }}"
#
#    - name: Enable UFW
#      ufw:
#        state: enabled

- name: Install fail2ban
  apt:
    name: fail2ban
    state: present

- name: Configure fail2ban for SSH
  copy:
    dest: /etc/fail2ban/jail.local
    content: |
      [DEFAULT]
      bantime = 3600
      findtime = 600
      maxretry = 5
      
      [sshd]
      enabled = true
      port = ssh
      logpath = /var/log/auth.log
  notify: Restart fail2ban

# ============================================
# SSH Hardening
# ============================================
- name: Harden SSH configuration
  lineinfile:
    path: /etc/ssh/sshd_config
    regexp: "{{ item.regexp }}"
    line: "{{ item.line }}"
    state: present
  loop:
    - { regexp: '^#?PermitRootLogin', line: 'PermitRootLogin no' }
    - { regexp: '^#?PasswordAuthentication', line: 'PasswordAuthentication no' }
    - { regexp: '^#?PubkeyAuthentication', line: 'PubkeyAuthentication yes' }
    - { regexp: '^#?X11Forwarding', line: 'X11Forwarding no' }
    - { regexp: '^#?MaxAuthTries', line: 'MaxAuthTries 3' }
    - { regexp: '^#?ClientAliveInterval', line: 'ClientAliveInterval 300' }
    - { regexp: '^#?ClientAliveCountMax', line: 'ClientAliveCountMax 2' }
  notify: Restart SSH

#    # ============================================
#    # User Management
#    # ============================================
#    - name: Create admin users
#      user:
#        name: "{{ item.name }}"
#        groups: sudo
#        append: yes
#        shell: /bin/bash
#        create_home: yes
#      loop: "{{ ubu_admin_users }}"
#      when: ubu_admin_users is defined
#
#    - name: Add SSH keys for admin users
#      authorized_key:
#        user: "{{ item.name }}"
#        key: "{{ item.ssh_key }}"
#        state: present
#      loop: "{{ ubu_admin_users }}"
#      when: ubu_admin_users is defined and item.ssh_key is defined
#
#    - name: Configure sudo without password for admin users
#      lineinfile:
#        path: /etc/sudoers.d/{{ item.name }}
#        line: "{{ item.name }} ALL=(ALL) NOPASSWD:ALL"
#        create: yes
#        mode: '0440'
#        validate: 'visudo -cf %s'
#      loop: "{{ ubu_admin_users }}"
#      when: ubu_admin_users is defined

# ============================================
# Swap Configuration
# ============================================
- name: Check if swap file exists
  stat:
    path: /swapfile
  register: swap_file

- name: Create swap file
  command: fallocate -l {{ ubu_swap_size_mb }}M /swapfile
  when: ubu_swap_size_mb > 0 and not swap_file.stat.exists

- name: Set swap file permissions
  file:
    path: /swapfile
    mode: '0600'
  when: ubu_swap_size_mb > 0 and not swap_file.stat.exists

- name: Format swap file
  command: mkswap /swapfile
  when: ubu_swap_size_mb > 0 and not swap_file.stat.exists

- name: Enable swap file
  command: swapon /swapfile
  when: ubu_swap_size_mb > 0 and not swap_file.stat.exists

- name: Add swap to fstab
  lineinfile:
    path: /etc/fstab
    line: '/swapfile none swap sw 0 0'
    state: present
  when: ubu_swap_size_mb > 0

- name: Set swappiness
  sysctl:
    name: vm.swappiness
    value: '10'
    state: present
    reload: yes
  when: ubu_swap_size_mb > 0

# ============================================
# System Optimization
# ============================================
- name: Configure kernel parameters
  sysctl:
    name: "{{ item.name }}"
    value: "{{ item.value }}"
    state: present
    reload: yes
  loop:
    - { name: 'net.ipv4.tcp_fin_timeout', value: '30' }
    - { name: 'net.ipv4.tcp_keepalive_time', value: '1200' }
    - { name: 'net.core.netdev_max_backlog', value: '5000' }
    - { name: 'fs.file-max', value: '2097152' }

- name: Set system limits
  pam_limits:
    domain: '*'
    limit_type: "{{ item.type }}"
    limit_item: "{{ item.item }}"
    value: "{{ item.value }}"
  loop:
    - { type: 'soft', item: 'nofile', value: '65536' }
    - { type: 'hard', item: 'nofile', value: '65536' }

# ============================================
# Docker Installation
# ============================================
- name: Remove old Docker versions
  apt:
    name:
      - docker
      - docker-engine
      - docker.io
      - containerd
      - runc
    state: absent

- name: Create Docker keyring directory
  file:
    path: /etc/apt/keyrings
    state: directory
    mode: '0755'

- name: Add Docker GPG key
  apt_key:
    url: https://download.docker.com/linux/ubuntu/gpg
    keyring: /etc/apt/keyrings/docker.gpg
    state: present

- name: Add Docker repository
  apt_repository:
    repo: "deb [arch=amd64 signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu {{ ansible_distribution_release }} stable"
    state: present
    filename: docker

- name: Install Docker packages
  apt:
    name:
      - docker-ce
      - docker-ce-cli
      - containerd.io
      - docker-buildx-plugin
      - docker-compose-plugin
    state: present
    update_cache: yes

- name: Ensure Docker service is started and enabled
  systemd:
    name: docker
    state: started
    enabled: yes

- name: Add users to docker group
  user:
    name: "{{ item }}"
    groups: docker
    append: yes
  loop: "{{ ubu_docker_users }}"
  when: ubu_docker_users | length > 0

- name: Configure Docker daemon
  copy:
    dest: /etc/docker/daemon.json
    content: |
      {
        "log-driver": "json-file",
        "log-opts": {
          "max-size": "10m",
          "max-file": "3"
        },
        "storage-driver": "overlay2"
      }
  notify: Restart Docker

- name: NFS - Create mount point
  file:
    path: "{{ item.dest }}"
    state: directory
    owner: "{{ ansible_user }}"
    group: "{{ ansible_user }}"
    mode: '0755'
  loop: "{{ nfs_mounts }}"
  when: nfs_mounts is defined and nfs_mounts | length > 0

- name: NFS - Mount share
  mount:
    src: "{{ item.src }}"
    path: "{{ item.dest }}"
    fstype: nfs
    opts: "{{ item.opts }}"
    state: mounted
  loop: "{{ nfs_mounts }}"
  when: nfs_mounts is defined and nfs_mounts | length > 0

# ============================================
# Monitoring & Logging
# ============================================
- name: Configure logrotate for Docker
  copy:
    dest: /etc/logrotate.d/docker
    content: |
      /var/lib/docker/containers/*/*.log {
        rotate 7
        daily
        compress
        missingok
        delaycompress
        copytruncate
      }

- name: Install log monitoring tools
  apt:
    name:
      - logwatch
      - gpg
      - wget
      - apt-transport-https
    state: present

- name: Create directory for GPG key
  file:
    path: /etc/apt/keyrings
    state: directory
    mode: '0755'

- name: Add Grafana GPG key
  apt_key:
    url: https://apt.grafana.com/gpg.key
    keyring: /etc/apt/keyrings/grafana.gpg
    state: present

- name: Add Grafana repository
  apt_repository:
    repo: "deb [signed-by=/etc/apt/keyrings/grafana.gpg] https://apt.grafana.com stable main"
    filename: grafana
    state: present

- name: Install Alloy
  apt:
    name: alloy
    state: present
    update_cache: yes

- name: Add alloy user to required groups
  user:
    name: alloy
    groups: docker,adm
    append: yes

- name: Configure Alloy to listen on all interfaces
  lineinfile:
    path: /etc/default/alloy
    regexp: '^CUSTOM_ARGS='
    line: 'CUSTOM_ARGS="--server.http.listen-addr=0.0.0.0:12345"'
    state: present
  notify: Restart Alloy

- name: Deploy Alloy configuration
  copy:
    dest: /etc/alloy/config.alloy
    owner: alloy
    group: alloy
    mode: '0644'
    content: |
      local.file_match "system_logs" {
          path_targets = [{"__path__" = "/var/log/*.log"}]
      }

      discovery.docker "containers" {
          host = "unix:///var/run/docker.sock"
      }

      discovery.relabel "docker_labels" {
          targets = []
          // forward_to = [loki.write.local_loki.receiver]

          // Clean up container name (removes the leading slash)
          rule {
              source_labels = ["__meta_docker_container_label_com_docker_compose_service"]
              target_label  = "container"
          }

          rule {
              source_labels = ["__meta_docker_container_label_com_docker_compose_project"]
              target_label  = "project"
          }
          
          rule {
              target_label = "instance"
              replacement  = constants.hostname
          }
          
          // Add a static job label
          rule {
              replacement  = "docker"
              target_label = "job"
          }
      }

      loki.source.file "host_logs" {
          targets    = local.file_match.system_logs.targets
          forward_to = [loki.write.local_loki.receiver]
      }

      loki.source.docker "docker_logs" {
          host       = "unix:///var/run/docker.sock"
          targets    = discovery.docker.containers.targets
          relabel_rules = discovery.relabel.docker_labels.rules
          // forward_to = [loki.relabel.docker_labels.receiver]
          forward_to = [loki.write.local_loki.receiver]

      }

      loki.write "local_loki" {
          endpoint {
              url = "{{ loki_url }}"
          }
      }

      // --- METRICS SECTION (New) ---

      // 1. Enable the internal Node Exporter
      prometheus.exporter.unix "node_exporter" {
          include_exporter_metrics = true
      }

      // 2. Scrape the internal exporter
      prometheus.scrape "scrape_node_exporter" {
          targets    = prometheus.exporter.unix.node_exporter.targets
          forward_to = [prometheus.remote_write.local_prometheus.receiver]
          
          // Optional: Add a job label
          scrape_interval = "15s"
      }

      // 3. Define where to send the metrics (Prometheus or Mimir)
      prometheus.remote_write "local_prometheus" {
          endpoint {
              url = "{{ prometheus_url }}"
          }
      }
      
      livedebugging {
        enabled = true
      }
  notify: Restart Alloy

- name: Ensure Alloy is started and enabled
  systemd:
    name: alloy
    state: restarted
    enabled: yes
    
# ============================================
# Final Steps
# ============================================
- name: Clean up package cache
  apt:
    autoclean: yes
    autoremove: yes

